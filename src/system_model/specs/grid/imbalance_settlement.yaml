model_part: imbalance_settlement
version: 1.0
tick_s: 1

description: >
  Nordic-style imbalance settlement for a single portfolio (the player), using 15-minute Imbalance Settlement Period (ISP).
  Implements a one-price scheme:
    - If the system is "up-regulating" (system short), both positive and negative deviations settle at the UP price.
    - If the system is "down-regulating" (system long), both deviations settle at the DOWN price.
    - If no material regulation, settle at Day-Ahead (DA) price for that hour.
  Computes deviation vs the player's DA schedule and produces cashflow + eSett-like per-volume fees.
  Horizon: real-time settlement; optional price curves provided by market_prices_known_ahead.

units:
  power: MW
  energy: MWh
  price_energy: EUR/MWh
  money: EUR
  time: s

inputs:
  time_now:
    unix_s: int

  # Player's committed day-ahead schedule (injection to grid).
  # +MW = discharge/sell to grid, -MW = charge/buy from grid.
  # Anchored to schedule_anchor_unix_s, step_s=3600, length 24.
  player_day_ahead_schedule:
    schedule_anchor_unix_s: int
    step_s: 3600
    schedule_MW_24: [float]

  # Actual measured portfolio exchange (BESS net power at PCC).
  # +MW = injection to grid, -MW = offtake from grid.
  metering:
    actual_net_power_MW: float

  # System state used to determine regulating direction (up/down/none).
  # imbalance_MW sign convention: positive = system surplus (long), negative = system deficit (short).
  system_frequency_and_imbalance:
    frequency_Hz: float
    imbalance_MW: float

  # Prices "known ahead" (your game shortcut).
  # imbalance prices are per 15-min MTU, anchored to prices_anchor_unix_s.
  prices_known_ahead:
    prices_anchor_unix_s: int          # unix time corresponding to index 0 of arrays below
    da_step_s: 3600
    da_price_EUR_per_MWh_24: [float]   # length 24
    imb_step_s: 900
    imb_price_up_EUR_per_MWh_96: [float]    # length 96
    imb_price_down_EUR_per_MWh_96: [float]  # length 96

  # Optional: toggle fees (BRP-style fees) on/off for gameplay.
  fees:
    enabled: bool

state:
  # Current ISP accumulator (15-min)
  current_isp_start_unix_s: int
  acc_actual_MWh: float
  acc_scheduled_MWh: float
  acc_system_imbalance_MWh: float

  # Last settled interval outputs (for UI/debug)
  last_settlement:
    isp_start_unix_s: int
    isp_end_unix_s: int
    system_direction: enum  # ["up_regulating","down_regulating","no_regulation"]
    settlement_price_EUR_per_MWh: float
    deviation_MWh: float
    imbalance_cashflow_EUR: float
    fee_volume_EUR: float
    fee_imbalance_EUR: float
    fee_weekly_alloc_EUR: float
    net_cashflow_EUR: float

  # Running totals
  totals:
    cumulative_deviation_MWh: float
    cumulative_net_cash_EUR: float

constants:
  # ISP (Nordics commonly use 15 min)
  isp_step_s: 900

  # Threshold for deciding "no regulation" (deadband around 0 system imbalance).
  # Game-stable: avoids flipping direction on tiny noise.
  system_regulation_deadband_MW: 150.0

  # If you want frequency to influence direction as well (optional):
  freq_nom_Hz: 50.0
  freq_deadband_Hz: 0.01

  # eSett-like fees (Sweden, Appendix 1 fees 1.9.2025)
  # Applied here as game costs. In reality these apply to BRPs; use enabled=false if you donâ€™t want them.
  esett_volume_fee_EUR_per_MWh: 2.000     # applied to absolute metered volume (production+consumption)
  esett_imbalance_fee_EUR_per_MWh: 1.150  # applied to absolute imbalance volume
  esett_weekly_fee_EUR: 30.0              # allocated evenly over the week

helpers:
  clamp: "clamp(x,a,b)=min(max(x,a),b)"
  clamp01: "clamp(x,0,1)"
  s_to_h: "s_to_h(s)=s/3600.0"

  # Index helpers (clamp to available horizon)
  idx_hour: >
    func(anchor_unix_s, t_unix_s):
      return clamp(floor((t_unix_s - anchor_unix_s)/3600), 0, 23)

  idx_qh: >
    func(anchor_unix_s, t_unix_s):
      return clamp(floor((t_unix_s - anchor_unix_s)/900), 0, 95)

init:
  current_isp_start_unix_s: "= floor(time_now.unix_s / isp_step_s) * isp_step_s"
  acc_actual_MWh: 0.0
  acc_scheduled_MWh: 0.0
  acc_system_imbalance_MWh: 0.0
  totals:
    cumulative_deviation_MWh: 0.0
    cumulative_net_cash_EUR: 0.0
  last_settlement:
    isp_start_unix_s: 0
    isp_end_unix_s: 0
    system_direction: "no_regulation"
    settlement_price_EUR_per_MWh: 0.0
    deviation_MWh: 0.0
    imbalance_cashflow_EUR: 0.0
    fee_volume_EUR: 0.0
    fee_imbalance_EUR: 0.0
    fee_weekly_alloc_EUR: 0.0
    net_cashflow_EUR: 0.0

update_per_tick:
  # 1) Determine current ISP boundaries
  - isp_start_now: "= floor(time_now.unix_s / isp_step_s) * isp_step_s"
  - isp_changed: "= (isp_start_now != state.current_isp_start_unix_s)"

  # 2) If ISP changed, settle the previous ISP using accumulated MWh
  - if isp_changed:
      - isp_start: "= state.current_isp_start_unix_s"
      - isp_end: "= isp_start + isp_step_s"

      # Average system imbalance over ISP (MW)
      - avg_sys_imbalance_MW: "= state.acc_system_imbalance_MWh * (3600.0 / isp_step_s)"
      - df_Hz: "= freq_nom_Hz - system_frequency_and_imbalance.frequency_Hz"

      # Determine regulation direction (one-price scheme driver)
      - system_direction: >
          if avg_sys_imbalance_MW <= -system_regulation_deadband_MW or df_Hz > freq_deadband_Hz:
            "up_regulating"
          else if avg_sys_imbalance_MW >= system_regulation_deadband_MW or df_Hz < -freq_deadband_Hz:
            "down_regulating"
          else:
            "no_regulation"

      # Look up prices for this ISP
      - k_price: "= idx_qh(prices_known_ahead.prices_anchor_unix_s, isp_start)"
      - h_price: "= idx_hour(prices_known_ahead.prices_anchor_unix_s, isp_start)"

      - da_ref_price: "= prices_known_ahead.da_price_EUR_per_MWh_24[h_price]"
      - up_price: "= prices_known_ahead.imb_price_up_EUR_per_MWh_96[k_price]"
      - down_price: "= prices_known_ahead.imb_price_down_EUR_per_MWh_96[k_price]"

      - settlement_price: >
          if system_direction == "up_regulating":
            up_price
          else if system_direction == "down_regulating":
            down_price
          else:
            da_ref_price

      # Deviation vs DA schedule
      - deviation_MWh: "= state.acc_actual_MWh - state.acc_scheduled_MWh"

      # One-price cashflow: +deviation => revenue, -deviation => cost (same price)
      - imbalance_cashflow_EUR: "= deviation_MWh * settlement_price"

      # Fees (optional)
      - fee_volume_EUR: >
          fees.enabled
          ? (abs(state.acc_actual_MWh) * esett_volume_fee_EUR_per_MWh)
          : 0.0

      - fee_imbalance_EUR: >
          fees.enabled
          ? (abs(deviation_MWh) * esett_imbalance_fee_EUR_per_MWh)
          : 0.0

      - fee_weekly_alloc_EUR: >
          fees.enabled
          ? (esett_weekly_fee_EUR / (7.0 * 24.0 * (3600.0/isp_step_s)))
          : 0.0

      - net_cashflow_EUR: "= imbalance_cashflow_EUR - fee_volume_EUR - fee_imbalance_EUR - fee_weekly_alloc_EUR"

      # Store last settlement
      - state.last_settlement.isp_start_unix_s: "= isp_start"
      - state.last_settlement.isp_end_unix_s: "= isp_end"
      - state.last_settlement.system_direction: "= system_direction"
      - state.last_settlement.settlement_price_EUR_per_MWh: "= settlement_price"
      - state.last_settlement.deviation_MWh: "= deviation_MWh"
      - state.last_settlement.imbalance_cashflow_EUR: "= imbalance_cashflow_EUR"
      - state.last_settlement.fee_volume_EUR: "= fee_volume_EUR"
      - state.last_settlement.fee_imbalance_EUR: "= fee_imbalance_EUR"
      - state.last_settlement.fee_weekly_alloc_EUR: "= fee_weekly_alloc_EUR"
      - state.last_settlement.net_cashflow_EUR: "= net_cashflow_EUR"

      # Update totals
      - state.totals.cumulative_deviation_MWh: "= state.totals.cumulative_deviation_MWh + deviation_MWh"
      - state.totals.cumulative_net_cash_EUR: "= state.totals.cumulative_net_cash_EUR + net_cashflow_EUR"

      # Reset accumulators and advance to new ISP
      - state.current_isp_start_unix_s: "= isp_start_now"
      - state.acc_actual_MWh: 0.0
      - state.acc_scheduled_MWh: 0.0
      - state.acc_system_imbalance_MWh: 0.0

  # 3) Accumulate within the current ISP (performed every tick)
  - dt_h: "= s_to_h(tick_s)"

  # Scheduled MW for this second comes from the DA hour covering current time
  - h_sched: "= idx_hour(player_day_ahead_schedule.schedule_anchor_unix_s, time_now.unix_s)"
  - scheduled_MW_now: "= player_day_ahead_schedule.schedule_MW_24[h_sched]"

  - state.acc_scheduled_MWh: "= state.acc_scheduled_MWh + scheduled_MW_now * dt_h"
  - state.acc_actual_MWh: "= state.acc_actual_MWh + metering.actual_net_power_MW * dt_h"
  - state.acc_system_imbalance_MWh: "= state.acc_system_imbalance_MWh + system_frequency_and_imbalance.imbalance_MW * dt_h"

outputs:
  isp:
    current_isp_start_unix_s: "= state.current_isp_start_unix_s"
    current_isp_end_unix_s: "= state.current_isp_start_unix_s + isp_step_s"
    seconds_into_isp: "= time_now.unix_s - state.current_isp_start_unix_s"
    step_s: "= isp_step_s"

  accumulators_live:
    scheduled_MWh_so_far: "= state.acc_scheduled_MWh"
    actual_MWh_so_far: "= state.acc_actual_MWh"
    deviation_MWh_so_far: "= state.acc_actual_MWh - state.acc_scheduled_MWh"

  last_settlement: "= state.last_settlement"

  totals: "= state.totals"
