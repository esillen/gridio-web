model_part: generation_nuclear_fleet
version: 3.1
tick_s: 1

description: >
  Swedish nuclear fleet with plants spelled out (Forsmark 1–3, Ringhals 3–4, Oskarshamn 3).
  No outages. Each unit ramps toward a planned setpoint with a limited ramp rate.
  "Think-ahead" within the current schedule step: starts ramping early so the next schedule point is reachable.

inputs:
  time_now:
    unix_s: int

  dispatch:
    mode: enum  # ["must_run", "follow_schedule_fleet", "follow_schedule_by_unit"]

    # Schedules are defined starting at "now" (index 0 = now), out to 24h.
    schedule_step_s: int  # recommended 900 (15 min) or 300 (5 min)

    # Used if mode == follow_schedule_fleet:
    schedule_target_fleet_MW: [float]  # length = 86400 / schedule_step_s

    # Used if mode == follow_schedule_by_unit:
    schedule_target_by_unit_MW:
      Forsmark_1: [float]
      Forsmark_2: [float]
      Forsmark_3: [float]
      Ringhals_3: [float]
      Ringhals_4: [float]
      Oskarshamn_3: [float]

state:
  units:
    Forsmark_1: { net_capacity_MW: 1104.0, current_MW: 1104.0 }
    Forsmark_2: { net_capacity_MW: 1121.0, current_MW: 1121.0 }
    Forsmark_3: { net_capacity_MW: 1172.0, current_MW: 1172.0 }
    Ringhals_3: { net_capacity_MW: 1081.0, current_MW: 1081.0 }
    Ringhals_4: { net_capacity_MW: 1134.0, current_MW: 1134.0 }
    Oskarshamn_3: { net_capacity_MW: 1400.0, current_MW: 1400.0 }

constants:
  # Simplified operating constraints
  min_stable_fraction: 0.50

  # Per-unit ramp cap (MW/s). Choose slow vs hydro; tune for gameplay.
  ramp_rate_MW_per_s_per_unit: 0.05   # 3 MW/min per unit

  # Optional additional fleet ramp cap (MW/s) after summing unit changes.
  ramp_rate_fleet_MW_per_s: 0.30      # 18 MW/min fleet

helpers:
  clamp: "clamp(x,a,b)=min(max(x,a),b)"
  sum_units: "sum over all units"

update_per_tick:
  # 1) Compute max/min for each unit
  - for_each_unit:
      - unit.max_MW: "= unit.net_capacity_MW"
      - unit.min_MW: "= min_stable_fraction * unit.max_MW"

  # 2) Determine schedule indices (schedule is defined from 'now')
  - step_s: "= dispatch.schedule_step_s"
  - steps_in_day: "= 86400 / step_s"
  - t_in_step_s: "= time_now.unix_s % step_s"
  - idx_now: 0
  - idx_next: 1
  - time_to_next_s: "= step_s - t_in_step_s"

  # 3) Get desired targets for 'now' and 'next'
  - if dispatch.mode == "must_run":
      - desired_fleet_now_MW: "= sum_units(unit.max_MW)"
      - desired_fleet_next_MW: "= desired_fleet_now_MW"

  - if dispatch.mode == "follow_schedule_fleet":
      - desired_fleet_now_MW: "= dispatch.schedule_target_fleet_MW[idx_now]"
      - desired_fleet_next_MW: "= dispatch.schedule_target_fleet_MW[idx_next]"

  # 4) Look-ahead feasibility adjustment (fleet-level)
  # Ensure that, given the remaining time in this schedule step, we can still reach the next target.
  - max_change_to_next_MW: "= ramp_rate_fleet_MW_per_s * time_to_next_s"

  - feasible_fleet_target_now_MW: >
      if dispatch.mode == "follow_schedule_fleet":
        clamp(
          desired_fleet_now_MW,
          desired_fleet_next_MW - max_change_to_next_MW,
          desired_fleet_next_MW + max_change_to_next_MW
        )
      else:
        desired_fleet_now_MW

  # 5) Convert fleet target into per-unit targets (capacity-proportional), unless unit schedule is provided
  - if dispatch.mode in ["must_run", "follow_schedule_fleet"]:
      - fleet_max_MW: "= sum_units(unit.max_MW)"
      - for_each_unit:
          - share: "= (fleet_max_MW > 0) ? (unit.max_MW / fleet_max_MW) : 0"
          - unit.target_MW_raw: "= feasible_fleet_target_now_MW * share"
          - unit.target_MW: "= clamp(unit.target_MW_raw, unit.min_MW, unit.max_MW)"

  - if dispatch.mode == "follow_schedule_by_unit":
      - for_each_unit:
          - desired_unit_now_MW: "= dispatch.schedule_target_by_unit_MW[unit_id][idx_now]"
          - desired_unit_next_MW: "= dispatch.schedule_target_by_unit_MW[unit_id][idx_next]"
          - max_change_to_next_unit_MW: "= ramp_rate_MW_per_s_per_unit * time_to_next_s"

          # Feasibility adjustment per unit (same idea as fleet-level)
          - unit.target_MW_preclamp: >
              clamp(
                desired_unit_now_MW,
                desired_unit_next_MW - max_change_to_next_unit_MW,
                desired_unit_next_MW + max_change_to_next_unit_MW
              )
          - unit.target_MW: "= clamp(unit.target_MW_preclamp, unit.min_MW, unit.max_MW)"

  # 6) Ramp each unit toward its target
  - for_each_unit:
      - delta_MW: "= unit.target_MW - unit.current_MW"
      - delta_limited_MW: "= clamp(delta_MW, -ramp_rate_MW_per_s_per_unit*tick_s, +ramp_rate_MW_per_s_per_unit*tick_s)"
      - unit.current_MW: "= clamp(unit.current_MW + delta_limited_MW, 0, unit.max_MW)"

outputs:
  production_MW: "= sum_units(unit.current_MW)"
  consumption_MW: 0.0

  production_by_unit_MW:
    Forsmark_1: "= state.units.Forsmark_1.current_MW"
    Forsmark_2: "= state.units.Forsmark_2.current_MW"
    Forsmark_3: "= state.units.Forsmark_3.current_MW"
    Ringhals_3: "= state.units.Ringhals_3.current_MW"
    Ringhals_4: "= state.units.Ringhals_4.current_MW"
    Oskarshamn_3: "= state.units.Oskarshamn_3.current_MW"

  available_capacity_by_unit_MW:
    Forsmark_1: "= state.units.Forsmark_1.net_capacity_MW"
    Forsmark_2: "= state.units.Forsmark_2.net_capacity_MW"
    Forsmark_3: "= state.units.Forsmark_3.net_capacity_MW"
    Ringhals_3: "= state.units.Ringhals_3.net_capacity_MW"
    Ringhals_4: "= state.units.Ringhals_4.net_capacity_MW"
    Oskarshamn_3: "= state.units.Oskarshamn_3.net_capacity_MW"

  available_capacity_total_MW: "= sum_units(unit.net_capacity_MW)"
  max_production_MW: "= sum_units(unit.net_capacity_MW)"
